#!/usr/bin/env bash
#
# non_exploit_recon.sh
# Non-exploitative pentest / recon automation script
# Purpose: passive + light active enumeration for a target domain.
# Usage: ./non_exploit_recon.sh target.example.com
# Optional env flags:
#   NIKTO=1   -> run nikto (light, non-destructive)
#   WPSCAN=1  -> run wpscan (safe defaults, throttled)
#
# IMPORTANT: Only run this script against assets you are explicitly authorized to test.
# This script intentionally avoids intrusive or destructive actions (no exploit modules,
# no full network port sweeps, no masscan -p-). Use more aggressive scans only with permission.
#

set -euo pipefail
IFS=$'\n\t'

### -------------------------
### Configuration / defaults
### -------------------------
TARGET="${1:-}"
if [[ -z "$TARGET" ]]; then
  echo "Usage: $0 target.example.com"
  exit 2
fi

# Output folder with timestamp
OUTDIR="./output/${TARGET}-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$OUTDIR"

# Concurrency choices (tunable)
THREADS=30           # used for httpx, dnsx etc (lower to be polite)
FFUF_THREADS=20      # dir fuzzing concurrency
NMAP_PORTS="80,443,8080,8443"  # only common web ports for light scan

# Tools this script will try to use (it will skip missing tools gracefully)
TOOLS=(subfinder amass assetfinder gau waybackurls dnsx httpx httprobe whatweb ffuf gobuster nmap nikto wpscan wafw00f jq)

echo "Target: $TARGET"
echo "Output: $OUTDIR"
echo "Tools will be used if available: ${TOOLS[*]}"
echo

### -------------------------
### Helper: check and run
### -------------------------
has() { command -v "$1" >/dev/null 2>&1; }

run_if() {
  # run a command if binary exists; show header
  local name="$1"; shift
  if has "$name"; then
    echo
    echo "===== Running: $* ====="
    "$@" || true
  else
    echo
    echo "----- Skipping: $name not installed -----"
  fi
}

### -------------------------
### 1) Passive subdomain discovery
### -------------------------
echo "[*] Passive subdomain discovery..."
# subfinder
run_if subfinder subfinder -d "$TARGET" -o "$OUTDIR/subfinder.txt"

# amass passive (if available)
run_if amass amass enum -passive -d "$TARGET" -o "$OUTDIR/amass_passive.txt"

# assetfinder (tomnomnom)
run_if assetfinder assetfinder --subs-only "$TARGET" > "$OUTDIR/assetfinder.txt" || true

# crt.sh via curl + jq (may be empty)
if has curl && has jq; then
  echo "----- querying crt.sh -----"
  curl -s "https://crt.sh/?q=%25.$TARGET&output=json" | jq -r '.[].name_value' 2>/dev/null | sed 's/\*\.//g' | sort -u > "$OUTDIR/crtsh_subs.txt" || true
else
  echo "----- skipping crt.sh (curl/jq missing) -----"
fi

# merge subdomain candidates into all_subs.txt
cat "$OUTDIR"/{subfinder.txt,amass_passive.txt,assetfinder.txt,crtsh_subs.txt} 2>/dev/null | sed 's/\*\.//g' | sort -u > "$OUTDIR/all_subs.txt" || true
echo "[*] Passive subdomain candidates: $(wc -l < "$OUTDIR/all_subs.txt" 2>/dev/null || echo 0)"

### -------------------------
### 2) Harvest indexed / historical URLs
### -------------------------
echo
echo "[*] Harvesting historical/indexed URLs (gau & waybackurls if available)..."
run_if gau gau "$TARGET" | sort -u > "$OUTDIR/gau_urls.txt"
run_if waybackurls waybackurls "$TARGET" | sort -u > "$OUTDIR/wayback_urls.txt"

# merge
cat "$OUTDIR"/{gau_urls.txt,wayback_urls.txt} 2>/dev/null | sort -u > "$OUTDIR/all_urls.txt" || true
echo "[*] Unique URLs collected: $(wc -l < "$OUTDIR/all_urls.txt" 2>/dev/null || echo 0)"

### -------------------------
### 3) Resolve hosts and probe HTTP(S)
### -------------------------
echo
echo "[*] Resolving hostnames and probing HTTP(S) endpoints..."

# Resolve hostnames to IPs (dnsx preferred)
if has dnsx && [[ -s "$OUTDIR/all_subs.txt" ]]; then
  cat "$OUTDIR/all_subs.txt" | dnsx -a -resp -silent -o "$OUTDIR/dnsx_resolved.txt" -threads $THREADS || true
  # dnsx outputs "<host> <ip>" lines; extract hosts
  awk '{print $1}' "$OUTDIR/dnsx_resolved.txt" 2>/dev/null | sort -u > "$OUTDIR/resolved_hosts.txt" || true
else
  # fallback simple resolve with dig
  if has dig && [[ -s "$OUTDIR/all_subs.txt" ]]; then
    while read -r h; do
      ip=$(dig +short "$h" | head -n1 || true)
      if [[ -n "$ip" ]]; then
        echo "$h $ip"
      fi
    done < "$OUTDIR/all_subs.txt" > "$OUTDIR/resolved_hosts.txt" || true
  fi
fi

# Also include target root
echo "$TARGET" >> "$OUTDIR/resolved_hosts.txt" 2>/dev/null || true
sort -u "$OUTDIR/resolved_hosts.txt" -o "$OUTDIR/resolved_hosts.txt" || true
echo "[*] Resolved hosts list: $(wc -l < "$OUTDIR/resolved_hosts.txt" 2>/dev/null || echo 0)"

# Probe for live HTTP(S) endpoints (httpx or httprobe)
if has httpx; then
  cat "$OUTDIR/resolved_hosts.txt" | httpx -threads $THREADS -silent -status-code -title -o "$OUTDIR/httpx_results.txt" || true
  awk '{print $1}' "$OUTDIR/httpx_results.txt" 2>/dev/null | sort -u > "$OUTDIR/live_hosts_http.txt" || true
elif has httprobe; then
  cat "$OUTDIR/resolved_hosts.txt" | httprobe -c $THREADS 2>/dev/null > "$OUTDIR/live_hosts_http.txt" || true
else
  echo "----- httpx/httprobe missing; will not probe HTTP endpoints automatically -----"
fi
echo "[*] Live HTTP endpoints: $(wc -l < "$OUTDIR/live_hosts_http.txt" 2>/dev/null || echo 0)"

# Basic WAF detection (wafw00f) on main target
run_if wafw00f wafw00f "https://$TARGET" > "$OUTDIR/wafw00f.txt" 2>/dev/null || true

### -------------------------
### 4) Web fingerprinting & lightweight checks
### -------------------------
echo
echo "[*] Fingerprinting and non-intrusive checks..."

# whatweb on main host + live endpoints
if has whatweb; then
  echo "$TARGET" > "$OUTDIR/whatweb_targets.txt"
  if [[ -s "$OUTDIR/live_hosts_http.txt" ]]; then
    cat "$OUTDIR/live_hosts_http.txt" >> "$OUTDIR/whatweb_targets.txt"
  fi
  sort -u "$OUTDIR/whatweb_targets.txt" -o "$OUTDIR/whatweb_targets.txt"
  while read -r url; do
    echo "----- whatweb -> $url" >> "$OUTDIR/whatweb_results.txt"
    whatweb -v "$url" >> "$OUTDIR/whatweb_results.txt" 2>/dev/null || true
  done < "$OUTDIR/whatweb_targets.txt"
fi

# quick curl headers for main target
if has curl; then
  curl -I -L -s "https://$TARGET" -o "$OUTDIR/headers_target.txt" || true
fi

### -------------------------
### 5) Directory discovery (non-destructive by default)
### -------------------------
echo
echo "[*] Directory discovery (polite defaults)..."
# If ffuf available, run a shallow directory discovery against main host (https)
if has ffuf; then
  # limit size by default; you can adjust wordlist if you want deeper scanning
  FFUF_WORDLIST="/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt"
  if [[ ! -f "$FFUF_WORDLIST" ]]; then
    FFUF_WORDLIST="/usr/share/wordlists/dirb/common.txt"
  fi
  if [[ -f "$FFUF_WORDLIST" ]]; then
    ffuf -u "https://$TARGET/FUZZ" -w "$FFUF_WORDLIST" -t $FFUF_THREADS -mc 200,301,302,403 -o "$OUTDIR/ffuf_root.json" -of json || true
  fi
elif has gobuster; then
  gobuster dir -u "https://$TARGET" -w /usr/share/wordlists/dirb/common.txt -t 20 -o "$OUTDIR/gobuster_root.txt" || true
else
  echo "----- no ffuf/gobuster installed; skipping dir discovery -----"
fi

### -------------------------
### 6) Light network/service scan (non-exploitative)
### -------------------------
echo
echo "[*] Light nmap service scan on common web ports (non-invasive)..."
if has nmap; then
  # gather IP list
  IPS=$(awk '{print $2}' "$OUTDIR/dnsx_resolved.txt" 2>/dev/null | sort -u | tr '\n' ' ' || true)
  if [[ -z "$IPS" ]]; then
    IPS=$(dig +short "$TARGET" | tr '\n' ' ' || true)
  fi
  if [[ -n "$IPS" ]]; then
    nmap -sS -Pn -T3 -p $NMAP_PORTS -sV -oA "$OUTDIR/nmap_light" $IPS || true
  else
    echo "----- No IPs discovered for nmap scan -----"
  fi
else
  echo "----- nmap not installed; skipping nmap scan -----"
fi

### -------------------------
### 7) Web scanners (nikto, wpscan) - optional (throttled)
### -------------------------
echo
echo "[*] Optional web checks (enable with environment flags):"
if [[ "${NIKTO:-0}" == "1" ]]; then
  run_if nikto nikto -h "https://$TARGET" -output "$OUTDIR/nikto.txt" || true
else
  echo " - Nikto skipped. Set NIKTO=1 to enable."
fi

if [[ "${WPSCAN:-0}" == "1" ]]; then
  # run a polite WPScan; requires WPScan installed; API token optional but recommended
  run_if wpscan wpscan --url "https://$TARGET" --enumerate u,ap,at --random-user-agent --throttle 1 --max-threads 2 -f json -o "$OUTDIR/wpscan_basic.json" || true
else
  echo " - WPScan skipped. Set WPSCAN=1 to enable (throttled)."
fi

### -------------------------
### 8) Aggregate & produce simple summaries
### -------------------------
echo
echo "[*] Aggregating outputs..."

# combine host lists found (harvester, subfinders, etc)
grep -Eo "([a-zA-Z0-9._-]+\.$TARGET)" -h "$OUTDIR"/* 2>/dev/null | sed 's/^\.//g' | sort -u > "$OUTDIR/hosts_grep_aggregate.txt" || true

# final deduped lists
if [[ -f "$OUTDIR/all_subs.txt" ]]; then
  cp "$OUTDIR/all_subs.txt" "$OUTDIR/final_subs.txt"
else
  touch "$OUTDIR/final_subs.txt"
fi

if [[ -f "$OUTDIR/all_urls.txt" ]]; then
  sort -u "$OUTDIR/all_urls.txt" -o "$OUTDIR/final_urls.txt"
else
  touch "$OUTDIR/final_urls.txt"
fi

echo "[*] Final hosts: $(wc -l < "$OUTDIR/final_subs.txt" 2>/dev/null || echo 0)"
echo "[*] Final URLs:  $(wc -l < "$OUTDIR/final_urls.txt" 2>/dev/null || echo 0)"

### -------------------------
### 9) Notes / next steps printed to console
### -------------------------
cat <<EOF > "$OUTDIR/README.txt"
Non-exploit recon run for: $TARGET
Outputs in this folder: $(ls -1 "$OUTDIR" | sed -n '1,200p')
Recommended next steps (with permission):
 - Review $OUTDIR/httpx_results.txt and $OUTDIR/whatweb_results.txt for tech fingerprinting
 - Manually inspect interesting URLs in $OUTDIR/final_urls.txt using Burp Suite / browser (set Burp proxy)
 - If WP detected and authorized, run authenticated WPScan or ask for staging/whitelist
 - Prepare findings summary with risk rating and reproducible steps
EOF

echo
echo "=== Recon complete ==="
echo "Output directory: $OUTDIR"
echo "Read $OUTDIR/README.txt for notes."
